---
layout: post
title:  "The One With My Learning Model"
date:   2019-01-09 20:43:47 +0100
---

Today I had my second 1-on-1 with my new(ish) boss and we talked about my learning path and its structure so this is a good opportunity for me to lay this out here a bit. In this post I will talk about
- how we got here
- the main aspects of my learning model
- what I think about this right now

### How we got here

I started working for Studitemps in August 2015 as a working student in Quality Assurance. When I was near the end of my studies, my boss at the time talked to me about my future at this company. I liked working there but I wanted to get into software engineering more, mainly for two reasons: There was not a big need for a QA person at that time and I had originally started studying an CS-related subject in order to become a developer, the QA position was just what Studitemps was looking for when I was looking for a job and something that I had already done a bit in my previous job.

I got my new contract in February 2017 but for several reasons started officially working as "one of the Software Engineers" in late 2017. In October 2018 I had my first 1-on-1 with my new boss and he asked how I see my progress. I said that I had learned a lot in the past year, mainly by pairing with one of the seniors and working on small tasks in one of our projects but I don't think I would be able to work on something big on my own yet. He suggested that I come up with a 3-month [OKR](https://weekdone.com/resources/objectives-key-results) goal like "I can implement a new feature in a new context on my own" until our next meeting. He also mentioned that he sees learning as a big topic for all of us, but me especially because I am the only one in a very junior position right now.

I looked into OKRs and felt intimidated. Then I remembered a SoCraTes Session about HolidayCheck's [apprenticeship program](http://apprenticeship.holidaycheck.com/) and started working on setting up something loosely inspired by this with one of my mentors. In an impromptu meeting I presented the rough outline to my boss and he liked the idea behind it so much that he is now working on setting something like this up for everyone who joins our department. Our own little apprenticeship program.

### Main aspects of my model

The main aspects of my model are the goal I am working towards, a practice project to guide my learning, a list of skills with a self assessment, two mentors, two weekly mentoring sessions (one being a refinement meeting), a kanban board to organise tasks, this blog and the structure that frames my learning time.

My **goal** is the one that we talked about before, being able to implement a new feature in a new context on my own. This doesn't mean that I am necessarily going to build a feature for our product completely on my own because we think pair programming and constant feedback are very important in order to build a great product. But it means that I feel confident to be able to do just that. Instead I am going to plan and build a **practice project**, a dashboard for our company that shows important KPI. In order to be able to do that, I need to acquire all the skills necessary to achieve my main goal.

There are loads of **skills** that a good software developer needs and we took inspiration from HolidayCheck again for the topics these skills or things to know fall into. Our final themes are:
- Testing
- Software Design
- Communication and Collaboration
- Agile Methods
- Tools (languages, frameworks, infrastructure)
- Fundamentals (my missing CS background)

For each theme we came up with a TON of subcategories and individual topics. We then took a look at my goal and decided which of these topics will help me in my quest to achieve this goal.

I then did a **self assessment**. On a scale from 0 = "I have no idea what this means" to 5 = "I could do a talk about this topic", I assessed my current level for each of the 14 topics that I am going to work on first. Each quarter, we will revisit these topics, do a new assessment and decide where I want or need to continue working on and what new topics would be good to focus on.

I have two **mentors**, two of the senior software engineers in my team. I meet with one of them every Monday in order to reflect on what I have learned in the past week and plan the new week. We use a **kanban board** to organise this: things that come up that I should be working on at some point go into the Backlog. Things that I think are good for the new week go into the Next section. During our **refinement meetings** we add items into the To Do section and I move them to Doing when I start working on something. After I am done, I move them to the Review section so we can talk about them in our next refinement meeting.

The **time management** part of my learning model is where the "loosely inspired" comes in: I am NOT an apprentice. I have been working and continue to work as part of one of our three scrum teams that plans, implements and delivers software to our internal users and customers. Learning just happens to be a big and fully-supported part of my day-to-day work life. In order to put more form and emphasis to this, we have talked about and committed to a time frame today (brand new, I'm excited how this will actually work out). In addition to my 2 hours of being mentored a week, I get 4 hours of learning time during work hours and I commit to doing 5 additional hours in my free time. The rest of the time will be spent working with my team on "real-world" software.

If any questions come up during either my learning time or while working on my own on our company software that I can't get an answer to on my own or right away from a coworker, I take them to my Wednesday mentoring session which we have actually been doing for about 2 years now and which has always been called Programming 101[^1].

This **blog** serves as a way to organise my thoughts, record important things I learned and reflect on learning path.

### What I think about this right now

If someone asked me about my progress 3 months ago, I enthusiastically replied "It's going great! I have learned so much during the past months and I feel like getting along so much better now!" This was only partly true. Yes, I had achieved a lot. But I still felt pretty lost a lot of the time. I had tried various methods of quantifying my learning (hours spent, questions answered, book chapters read) but I still felt like I was not doing enough. On the other hand I had no idea how much time I was "allowed" to spend on learning. Enough to be able to help me with small problems? Enough to understand our software better? So if I am reading a 400-page Elixir book, is that justified, seeing as we get closer to an important deadline and there are lots of small things that I could be doing instead, helping my team produce more output? And what should I be learning anyways?

I now have a goal and a practice project that tell me what I should be learning. I have two experienced software engineers that help me come up with actual tasks that are essentially small steps towards my goal. I review theses steps weekly and get feedback on my progress. I have management support so I can justify to myself and others (the former being the far more judging part) the time I spend on learning. I have a clear time frame each week that I can track. This feels like just what I needed.

I will do an update post about my learning model and my progress so far at least every other month from now on to evaluate this further.

---


[^1]: I asked the coworker that I had known for the longest time if he was willing to help me fill my gaps in computer science fundamentals. He said yes, I decided a weekly meeting would be a good way to start and we would both forget about it without a calendar entry. This calendar entry needed a name, I was in a hurry, Programming 101 sounded like a fun inside joke. My calendar only shows whether I'm busy or not, so nobody would see this. Weeks later I realised that everyone in the company can see this when they try to schedule a meeting and look into the rooms calendars to find the best place and time for a meeting. Oh well ...
